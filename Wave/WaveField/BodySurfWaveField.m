classdef BodySurfWaveField < FBWaveField
    % BODYSURFWAVEFIELD: represent a wave field (i.e. pressures and
    % velocities over a body surface). Inherits from FBWaveField (i.e.
    % floating body wave field), which is a wave field generated by
    % floating bodies that includes an:
    %   - Incident wave field
    %   - Scattered wave field (or diffracted wave field which is sum of 
    % incident and scattered)
    %   - Radiated wave fields for motions in each DOF
    %
    % The above wave field elements can be summed including the body
    % motions to produce a so-called 'Total' wave field.
    
    properties (Access = private)
        bodyGeo;
        bodyInds;
        motionFuncs;
        motBodyInds;
    end
    
    properties (Dependent)
        BodyGeo;
        BodyInds;
        BodyCount;
        MotionFuncs;
        MotionBodyInds;
    end
    
    methods
        function [wf] = BodySurfWaveField(body, iwave, swave, varargin)
            
            if (~isa(body, 'PanelGeo'))
                error('Body must be a PanelGeo');
            end
            if (iwave.IsArray)
                error('BodySurfWaveField must be a collection of points');
            end
            
            bodyPnts = body.Centroids;
            wfPnts = iwave.FieldPoints;
            
            Npnts = size(bodyPnts, 1);
            
            if (Npnts ~= size(wfPnts, 1))
                error('The body points and wave field points must be the same');
            end
            
            for n = 1:Npnts
                if any(abs(bodyPnts(n,:) - wfPnts(n,:)) > 1e-6*[1 1 1])
   %                  error('The body points and wave field points must be the same');
                end
            end
            
            wf = wf@FBWaveField(iwave, swave, varargin{:});
            
            wf.bodyGeo = body;
        end
        
        function [bod] = get.BodyGeo(wf)
            bod = wf.bodyGeo;
        end
        
        function [val] = get.BodyInds(wf)
            val = wf.bodyInds;
        end
        function [] = set.BodyInds(wf, val)
            if length(val) ~= wf.bodyGeo.Count
                error('BodyInds vector must be same length as number of panels');
            end
            wf.bodyInds = val;
        end
        
        function [val] = get.BodyCount(wf)
            val = length(unique(wf.bodyInds));
        end
        
        function [val] = get.MotionFuncs(wf)
            val = wf.motionFuncs;
        end
        function [] = set.MotionFuncs(wf, val)
            if ~isa(val, 'IMotionFunc')
                error('MotionFuncs must be an IMotionFunc');
            end
            wf.motionFuncs = val;
        end
        
        function [val] = get.MotionBodyInds(wf)
            val = wf.motBodyInds;
        end
        function [] = set.MotionBodyInds(wf, val)
            if ~isempty(wf.motionFuncs)
                if length(val) ~= length(wf.motionFuncs)
                    error('MotionBodyInds vector must be same length as number of MotionFuncs');
                end
            end
            wf.motBodyInds = val;
        end
                
        function [panGeos] = Pressure(obj, type)
            % PRESSURE: returns the complex-valued pressure over the body 
            % surface.
            %
            %   Inputs:
            %       - type: type of wave field. char. Options are:
            %           - 'Hydrostatic'
            %           - 'MotionHydrostatic'
            %           - 'Incident'
            %           - 'Scattered'
            %           - 'Diffracted'
            %           - 'Radiated'
            %           - 'Total'
            %
            %   Outputs:
            %       - panGeos: cell area of PanelGeos, where values on 
            %       PanelGeo are the complex pressures. Size of cell array
            %       based on number of wave periods, incident wave
            %       directions, and DoF depending on type of wave field.
            
            rho = obj.Rho;
            g = obj.G;
            points = obj.FieldPoints;
            [Np, ~] = size(points);
            
            if strcmpi(type, 'Hydrostatic')
                z = points(:,3);
                z(z > 0) = 0;
                p = {-rho*g*z};
            elseif strcmpi(type, 'MotionHydrostatic')
                if isempty(obj.motionFuncs)
                    error('WaveField.MotionFuncs empty. Cannot compute MotionHydrostatic');
                end
                
                motions = obj.BodyMotions;
                funcs = obj.motionFuncs;
                
                bInds = obj.bodyInds;
                mInds = obj.motBodyInds;
                
                [M, N, dof] = size(motions);
                
                if isempty(bInds)
                    bInds = ones(Np, 1);
                end
                
                if isempty(mInds)
                    mInds = ones(dof, 1);
                end
                
                p = cell(M, N);

                for m = 1:M
                    for n = 1:N
                        pmn = zeros(Np, 1);
                        for o = 1:Np
                            if points(o,3) <= 0
                                for q = 1:dof
                                    if bInds(o) == mInds(q)
                                        del = motions(m, n, q)*funcs(q).Evaluate(points(o,:));
                                        pmn(o) = pmn(o) + -rho*g*del(3);  
                                    end
                                end
                            end
                        end
                        p{m, n} = pmn;
                    end
                end
            else
                p = obj.pressure(type);
            end
            
            panGeos = cell(size(p));
            N = numel(p);
            
            for n = 1:N
                pgeon = PanelGeo(obj.bodyGeo);
                pgeon.Values = p{n};
                panGeos{n} = pgeon;
            end
        end
                
        function Elevation(obj, type)
            % ELEVATION: Elevation not implement for BodySurfWaveField
            error('Elevation not implemented for BodySurfWaveField');
        end
        
        function [velgeo] = Velocity(obj, type)
            % VELOCITY: returns the complex-valued fluid velocity over the 
            % body surface.
            %
            %   Inputs:
            %       - type: type of wave field. char. Options are:
            %           - 'Incident'
            %           - 'Scattered'
            %           - 'Diffracted'
            %           - 'Radiated'
            %           - 'Total'
            %
            %   Outputs:
            %       - panGeos: cell area of PanelGeos, where values on 
            %       PanelGeo are the complex velocities. Size of cell array
            %       based on number of wave periods, incident wave
            %       directions, and DoF, and velocity in x, y, z depending 
            %       on type of wave field.
            
            vel = obj.velocity(type);
            velgeo = cell(size(vel));
            N = numel(vel);
            
            for n = 1:N
                velgeon = PanelGeo(obj.bodyGeo);
                velgeon.Values = vel{n};
                velgeo{n} = velgeon;
            end
        end
        
        function SigWaveHeight(obj, type)
            % SIGWAVEHEIGHT: SigWaveHeight not implement for BodySurfWaveField
            error('SigWaveHeight not implemented for BodySurfWaveField');
        end
        
        function Spectra(obj, varargin)
            % SPECTRA: Spectra not implemented for BodySurfWaveField
            error('Spectra not implemented for BodySurfWaveField');
        end
        
        function [fluxGeo] = EnergyFlux(obj, type, varargin)
            % ENERGYFLUX: returns the real-valued energy flux density 
            % [W/m^2] over the body surface.
            %
            %   Inputs:
            %       - type: type of wave field. char. Options are:
            %           - 'Incident'
            %           - 'Scattered'
            %           - 'Diffracted'
            %           - 'Radiated'
            %           - 'Total'
            %
            %   Optional Inputs:
            %       - 'Spectra', spectra: a WaveSpectrum object or cell
            %       array of WaveSpectrums. If input, the output will be
            %       the average energy-flux density for that spectrum
            %
            %   Outputs:
            %       - panGeos: cell area of PanelGeos, where values on 
            %       PanelGeo are the energy flux densities. Size of cell 
            %       array based on number of wave periods, incident wave
            %       directions, and DoF, depending on type of wave field.
            
            [opts, args] = checkOptions({{'Spectra', 1}}, varargin);
            specs = cell(0);
            if opts(1)
                specs = args{1};
                if ~iscell(specs)
                    specs = {specs};
                end
            end
            
            fluxGeo = obj.bodyGeo;
            
            pnts = fluxGeo.Centroids;
            norms = fluxGeo.Normals;
            areas = fluxGeo.Areas;
            surf = ControlSurface(pnts, norms, areas);
            
            flux = obj.energyFlux(surf, type, 'PerPoint');

            if ~isempty(specs)
                fluxGeo = cell(size(specs));
                M = numel(specs);
                N = numel(flux);
                Npan = obj.bodyGeo.Count;
                
                fluxArray = zeros([Npan, size(flux)]);
                for n = 1:N
                    fluxArray(:,n) = flux{n};
                end
            
                for m = 1:M
                    fluxGeon = PanelGeo(obj.bodyGeo);
                    amps = specs{m}.Amplitudes;
                    if iscolumn(amps)
                        amps = amps';
                    end
                    amps = ones(Npan, 1)*amps;
                    fluxGeon.Values = sum(fluxArray.*amps.^2, 2);
                    fluxGeo{m} = fluxGeon;
                end
            else
                fluxGeo = cell(size(flux));
                N = numel(flux);

                for n = 1:N
                    fluxGeon = PanelGeo(obj.bodyGeo);
                    fluxGeon.Values = flux{n};
                    fluxGeo{n} = fluxGeon;
                end
            end
        end
        
        function [Fe] = WritePressureFile(obj, folder, name, time, iT, A, bodyInds, bodyNames, deltaPoints, compForce)
            % if time less than 1, compute hydrostatic pressure
            if nargin < 4
                time = 0;
            end
            
            if nargin < 5
                iT = 1;
            end
            
            if nargin < 6
                A = 1;
            end
            
            if nargin < 7
                bodyInds = [];
            end
            
            if nargin < 8
                bodyNames = [];
            end
            
            if nargin < 9
                deltaPoints = [];
            end
            if isempty(deltaPoints)
                deltaPoints = [0 0 0];
            end
            
            Fe = [];
            if nargin < 10
                compForce = false;
            end
            
            if isempty(iT)
                iT = 1;
            end
                                    
            geo = obj.bodyGeo;
            cents = geo.Centroids;
            
            T = obj.T(iT);
                        
            pressH0 = obj.Pressure('Hydrostatic');
            pressH0 = pressH0{1}.Values;
            pressHs = obj.Pressure('MotionHydrostatic');
            pressHs = pressHs{iT}.Values;
            pressHd = obj.Pressure('Total');
            pressHd = pressHd{iT}.Values;
            
            Np = geo.Count;
            
            if isempty(bodyInds)
                bodyInds = 1;
            end
            
            if compForce
                funcs = obj.motionFuncs;
                minds = obj.MotionBodyInds;
                Nf = length(funcs);
                Fe = cell(length(time), length(bodyInds));
            end
                        
            for m = 1:length(time)
                
                if time(m) < 0
                    At = 1;
                    
                    tstr = 'pressHydrostatic';
                else
                    phase = wrapTo2Pi(time(m)/T*2*pi);
                    At = A*exp(1i*phase);
                    
                    tstr = num2str(time(m), '%4.2f');
                    tstr(tstr == '.') = '-';
                    tstr = ['t' tstr];
                end
                
                for nb = 1:length(bodyInds)
                    
                    if compForce
                        finds = zeros(Np, 1);
                    end
                    
                    if isempty(bodyNames)
                        bstr = ['bod' num2str(nb)];
                    else
                        bstr = bodyNames{nb};
                    end
                                        
                    if time(m) < 0
                        fileName = [folder '\' name '_' tstr '_' bstr '.csv'];
                    else
                        fileName = [folder '\' name '_' tstr '_press_' bstr '.csv'];
                    end

                    header = {'x (m)', 'y (m)', 'z (m)', 'pressure (Pa)'};

                    N = sum(obj.bodyInds == bodyInds(nb));
                    M = zeros(N, 4);
                    np = 1;
                    for n = 1:Np
                        if obj.bodyInds(n) == bodyInds(nb)
                            M(np, 1:3) = cents(n,:) + deltaPoints;
                            if time(m) < 0
                                M(np, 4) = pressH0(n);
                            else
                                M(np, 4) = pressH0(n) + real(At*(pressHs(n) + pressHd(n)));
                            end

                            np = np+1;
                            if compForce
                                finds(n) = 1;
                            end
                        end
                    end

                    fid = fopen(fileName, 'w');
                    fprintf(fid, '%s,%s,%s,%s\n', header{1}, header{2}, header{3}, header{4});

                    for n = 1:N
                        fprintf(fid, '%7.3f,%7.3f,%7.3f,%8.0f\n', M(n,1), M(n,2), M(n,3), M(n,4));
                    end
                    fclose(fid);
                    
                    if compForce
                        Fe{m, nb} = zeros(3, 1);
                        finds = logical(finds);
                        P = zeros(size(finds));
                        P(finds) = M(:,4);
                        for n = 1:Nf
                            if minds(n) == bodyInds(nb)
                                if bodyInds(nb) == 2
                                    Fe{m, nb}(n-3) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), P, finds);
                                else
                                    Fe{m, nb}(n) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), P, finds);
                                end
                            end
                        end
                    end
                end
            end
           
        end
        
        function [forceHs0, forceHsM, forceHd, forceHs0e, forceHsMe, forceHde] ...
                = CheckPressureForce(obj, mass, dofSur, dofHea, dofPit, hydroForces, type, iT, correctHs)
            
            if nargin < 7
                type = 'Total';
            end
            if nargin < 8
                iT = 1;
            end
            if nargin < 9
                correctHs = false;
            end
            
            xi = obj.BodyMotions;
            
            pressHs0 = [];
            pressHsM = [];
            pressHd = [];
            pressTot = [];
            
            if strcmpi(type, 'Hydrostatic') || strcmpi(type, 'Total') %|| correctHs
                press = obj.Pressure('Hydrostatic');
                pressHs0 = press{1};
            end
            
            if strcmpi(type, 'MotionHydrostatic') || strcmpi(type, 'Total')
                press = obj.Pressure('MotionHydrostatic');
                pressHsM = press{iT};
            end
            
            if strcmpi(type, 'Dynamic') || strcmpi(type, 'Total')
                % 'Total' as an input to the Pressure method means the sum
                % of the radiated and diffracted pressure
                press = obj.Pressure('Total');
                pressHd = press{iT};
            end
            
%             if strcmpi(type, 'Total')
%                 pressTot = pressHs0.Values + pressHd.Values + pressHsM.Values;
%             end
                        
            geo = obj.bodyGeo;
            funcs = obj.motionFuncs;
            bInds = obj.bodyInds;
            mInds = obj.motBodyInds;
            Nf = length(funcs);
            
            forceHs0 = zeros(Nf, 1);
            forceHsM = zeros(Nf, 1);
            forceHd = zeros(Nf, 1);
            forceTot = zeros(Nf, 1);
            
            for n = 1:Nf
                
                inds = mInds(n) == bInds;
                
                if ~isempty(pressHs0)
                    forceHs0(n) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), pressHs0.Values, inds);
                end
                if ~isempty(pressHsM)
                    forceHsM(n) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), pressHsM.Values, inds);
                end
                if ~isempty(pressHd)
                    forceHd(n) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), pressHd.Values, inds);    
                end
                if ~isempty(pressTot)
                    forceTot(n) = BodySurfWaveField.ComputeForceFromPress(geo, funcs(n), pressTot, inds);
                end
            end
            
            xi = squeeze(xi(iT, 1, :));
            g = IWaves.G;
            
            if isrow(mass)
                mass = mass';
            end
            
            forceHs0e = zeros(size(forceHs0));
            forceHs0e(dofHea) = -mass*g;
            
            if correctHs
                %mass = -forceHs0(dofHea)./g;
                forceHs0 = forceHs0e;
            end
            
            forceHsMe = zeros(size(forceHsM));
            forceHsMe(dofSur) = g*mass.*xi(dofPit);
            forceHsMe = forceHsMe + hydroForces.C*xi;
            
            Fex = squeeze(hydroForces.Fex(iT,1,:));
            A = squeeze(hydroForces.A(iT,:,:));
            B = squeeze(hydroForces.B(iT,:,:));
            w = 2*pi/hydroForces.T(iT);
            forceHde = -(Fex + w^2*A*xi - 1i*w*B*xi);
            
            if strcmpi(type, 'Hydrostatic')
                force = forceHs0;
                forceExp = forceHs0e;
            elseif strcmpi(type, 'MotionHydrostatic')
                force = forceHsM;
                forceExp = forceHsMe;
            elseif strcmpi(type, 'Dynamic')
                force = forceHd;
                forceExp = forceHde;
            elseif strcmpi(type, 'Total');
                force = forceHs0 + forceHsM + forceHd;
                forceExp = forceHs0e + forceHsMe + forceHde;
            end
            
            err = abs(force-forceExp)./abs(forceExp)*100;
            
            fprintf('\n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
            
            for n = 1:length(force)
                if ~isa(funcs(n), 'ZeroMotionFunc')
                    fprintf('\nBody: %i,\t%s\nForce \t\t\t= %4.2e*exp(%0.0fi),\nForce Expected \t= %4.2e*exp(%0.0fi)\nError \t\t\t= %4.1f\n\n',...
                        mInds(n), class(funcs(n)), abs(force(n)), 180/pi*angle(force(n)), abs(forceExp(n)), 180/pi*angle(forceExp(n)), err(n))
                end
            end
            
            fprintf('\nCOMPLETE~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n');
        end
    end
    
    methods (Static)
        function [force] = ComputeForceFromPress(geo, func, press, inds)            
            N = geo.Count;
                        
            if nargin < 4
                inds = ones(N, 1);
            else
                N = sum(inds);
            end
            
            cents = geo.Centroids;
            norms = geo.Normals;
            areas = geo.Areas;
            
            cents = cents(inds, :);
            norms = norms(inds, :);
            areas = areas(inds);
            press = press(inds);
            
            normMot = zeros(N, 3);
            dotNorm = zeros(N, 1);
            
            for n = 1:N
                normMot(n, :) = func.Evaluate(cents(n,:));
                dotNorm(n) = dot(normMot(n,:), norms(n,:));
            end

            force = sum(dotNorm.*areas.*press);
        end
    end
end